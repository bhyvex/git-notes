= Why the index/staging area is so useful

^^[[TOC]]^^

----

>   ^^Newcomers to git often ask why there is such a thing as the index, and
    what use is it.  If you don't understand what the index does, it might
    seem like one extra (and needless) complication.

    So... what use is this?^^

=== staging helps in reviewing changes

Staging helps you "check off" individual changes as you review a complex
commit, and to concentrate on the stuff that has not yet passed your review.
Let me explain.

Before you commit, you'll probably review the whole change by using {{{git
diff}}}.  If you stage each change as you review it, you'll find that you can
concentrate better on the changes that are not yet staged.

{{{git gui}}} is great here.  It's two left panes show unstaged and staged
changes respectively, and you can move files between those two panes
(stage/unstage) just by clicking on the icon to the left of the filename.

Even better, you can even stage //partial changes// to a file.  In the right
pane of {{{git gui}}}, right click on a change that you approve of and choose
"stage hunk".  //Just that change// (not the entire file) is now staged; in
fact, if there are other, unstaged, changes in that same file, you'll find
that the file now appears on //both// top and bottom left panes!

^^[Do remember, however, that if the change is really complex maybe you should
split it into multiple commits!]^^

=== staging helps when merging

When a merge happens, changes that merge cleanly are updated both in the
staging area as well as in your work tree.  Only changes that did not merge
cleanly (i.e., caused a conflict) will show up when you do a {{{git diff}}},
or in the top left pane of {{{git gui}}}.

Again, this lets you concentrate on the stuff that needs your attention -- the
merge conflicts.

=== staging helps you keep extra local files hanging around

Usually, files that should not be committed go into {{{.gitignore}}} or the
local variant, {{{.git/info/exclude}}}.

However, sometimes you want a local change to a file that cannot be excluded
(which is not good practice but can happen sometimes).  For example, perhaps
you upgraded your build environment and it now requires an extra flag or
option for compatibility, but if you commit the change to the Makefile, the
other developers will have a problem.

Of course you have to discuss with your team and work out a more permanent
solution, but right now, you //need// that change in your working tree to do
//any// work at all!

Another situation could be that you want a new local file that is temporary,
and you don't want to bother with the ignore mechanism.  This may be some test
data, a log file or trace file, or a temporary shell script to automate some
test... whatever.

In git, all you have to do is never to stage that file or that change.  That's
it.

=== staging helps you sneak in small changes ;-)

Let's say you're in the middle of a somewhat large-ish change and you are told
about a very important bug that needs to be fixed asap.

The usual recommendation is to do this on a separate branch, but let's say
this fix is really just a line or two, and can be tested just as easily
without affecting your current work.

With git, you can quickly make and commit //only that change//, without
committing all the other stuff you're still working on.

Again, if you use {{{git gui}}}, whatever's on the bottom left pane gets
committed, so just make sure only that change gets there and commit, then
push!

==== a word of warning...

While the first 3 use cases are perfectly legitimate and useful uses of the
index, this last example could be dangerous if you get carried away.

You cannot actually compile and test what is in the index, ignoring the rest
of the unstaged changes.  The index does not exist as a "tree" on the file
system.

So, strictly speaking, you did not test the precise change which you committed
there; you tested that change //plus// a whole bunch of "pending" stuff in the
work tree.  You have to be sure the test succeeded **only** because of that
one change, and not any of the pending stuff.

And if you're not 150% sure, you should do this the proper way: in a separate
branch, using {{{git stash}}} to temporarily save away your uncommitted work
if needed.

Using a powerful DVCS does not absolve you from the responsibility of thinking
:-)
