# terminology

^^[[TOC]]^^

### general VCS terminology

A **project** is the minimum set of source code (and related files) that need
to be kept together to **build** the software.  Example: Linux

  * each project will have one **repository**
  * one **team** can work on multiple projects, so there could be multiple
    repositories on each desktop

A **branch** in a project is an active line of development

  * **master** is the conventional name for the main development tree of a
    project
  * other conventional branches are **next** (for code that is ready to come
    into *main*), and various maintenance branches like **v1.3** or
    __v2.6.4__ to designate released versions
  * these are only conventions, not rules, but they seem to work well in
    general

A **feature** is a part of a project that is large and complex enough that
it's day-to-day commits would be too noisy to include in the main project.
Example: the disk subsystem, the networking subsystem, etc., in Linux

  * a **feature branch** is a branch for a feature, and is usually long-lived.
    This means it regularly acquires changes made in the main line, and -- at
    stable points in its development cycle -- merges its changes back into the
    main line
  * small projects may not have any feature branches.  That doesn't mean they
    don't have any features :-)

### git-specific terminology

#### branch, master, head, HEAD, etc

  * a branch is "an active line of development"
  * *master*: default branch in a project (main development tree), by
    convention
  * *head*: tip of a branch
  * a repository can track many branches, but the working tree is associated
    with only one branch at a time
  * *HEAD*: tip of the branch associated with the working tree; this is where
    commits go.  Normally.  There is also something called a 'detached HEAD'
    that you should be aware of.  See the article on the [detached
    HEAD](detached-head.html) for more.
  * *index*: a staging area for the next commit; when you commit, the current
    index is turned into a real commit object
  * *origin*: when you clone an existing project in order to start working on
    it, the project you cloned *from* is traditionally called the "origin" of
    your clone

#### terminology related to being "distributed"

##### clone versus checkout

In a *distributed* VCS, every developer's workstation has a full copy of the
entire repository.  It is therefore called a **clone** -- you **clone** the
remote repository, you don't merely *checkout* the latest version from it.

So where does *checkout* come in?  In git, you **checkout** a *branch* from
your local repo, so this happens *after* the clone.  Remember this is a full
repo, so you already have all the branches that the parent repo had when you
cloned.

By default, after the clone is done, git will **checkout** the branch that was
currently checked out the same branch that the parent currently has checked
out.  However, you can checkout some other branch at any time (and if you're
using git, you will checkout and manage multiple branches on your local repo
all the time, otherwise you're not really *using* git!)

##### accessing remote repositories

Every remote repository (often called just a **remote**) has a URL associated
with it, depending on how your local repo is able to reach it.  The simplest
URL is for a repo that is on the same machine, which can then use the *file*
protocol: `file:///home/sitaram/path/to/repo.git`.

Anonymous access (read-only) repositories can be grabbed using the *git*
protocol; for example, Linus Torvalds' version of the current Linux kernel is
at `git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git`.
Read-only repos can also use the HTTP protocol, although this is not as
efficient for continuous use.

A remote repository to which you have write access will almost certainly use
*ssh* as the underlying authentication protocol, so the remote URL might look
like `ssh://sitaram@172.1.7.2/full/path/to/repo.git`.

##### naming remote repositories

You can refer to, (or fetch from, and push to) many remote repos in *your*
clone, because they all have different URLs.  After a while it gets
inconvenient to use the full URLs in your `git fetch` and `git push` commands,
so git allows you to give an easy to remember "nickname" for each "remote".  I
could, for instance, do this:

    git remote add sejal ssh://sitaram@sejal.herlab.ourcompany.com/path/to/repo.git

After this I could refer to the longer URL by the shortname "sejal" and it
would be the same thing.

##### origin

So now you know what a nickname is, you can understand what "origin" means.
"origin" is just the default name given to the remote repository when you do a
`git clone`.  So for example, if I do

    git clone ssh://sitaram@sejal.herlab.ourcompany.com/path/to/repo.git

then, after the clone completes, git automatically creates a remote with the
nickname `origin`, which points to
`ssh://sitaram@sejal.herlab.ourcompany.com/path/to/repo.git`.  It's just a
convenience thing.  You can delete that nickname, you can rename it to
something else, etc., if you like.

#### what is a "bare" repository?

This has been moved into it's [own page](bare.html) now.
