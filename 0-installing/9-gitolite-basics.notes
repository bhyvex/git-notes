# (admin) how gitolite uses ssh magic

^^[[TOC]]^^

----

^^This document used to be about gitosis, but I have now stopped using it, in
favour of a much better tool called gitolite (I wrote it, so please allow me
my biases!).  Questions like why, what, and how, can be answered
[here](http://github.com/sitaramc/gitolite), but the big reason is "per-branch
permissions" -- the ability to specify who can fetch/push/force-push what
branch.

However, large parts of this document are actually about ssh, which is the
real magic behind *both* these tools.  So please do read it even if you're
using gitosis.  I'm sure it will still be useful, because **it's quite likely
that your problem is more about ssh, even if you didn't know it** :-)

This document is only a "how", not a "how **to**".  The gitosis-version of
this document was both, because gitosis didn't have much docs.  Gitolite has
[lots](http://github.com/sitaramc/gitolite/tree/pu/doc/), and you should
really use those to install and use it :-)^^

----

### why gitolite

Gitolite is separate from git, and needs to be installed and configured.  So...
why do we bother?

Gitolite is useful in any server that is going to host multiple git
repositories, each with many developers, where some sort of access control is
required.

In theory, this can be done with plain old Unix permissions: each user is a
member of one or more groups, each group "owns" one or more repositories, and
using unix permissions (especially the setgid bit -- `chmod g+s`) you can
allow/disallow users access to repos.

But there are several disadvantages here:

  * every user needs a userid and password on the server.  This is usually a
    killer...!
  * adding/removing access rights involves complex `usermod -G ...` mumblings
    which most admins would rather not deal with, thanks to you-know-who
  * *viewing* (aka auditing) the current set of permissions requires running
    multiple commands to list directories and their permissions/ownerships,
    users and their group memberships, and then correlating all these manually
  * auditing historical permissions or permission changes is pretty much
    impossible without extraneous tools
  * errors or omissions in setting the permissions exactly can cause problems
    of either kind: false accepts or false rejects
  * without going into ACLs it is not possible to give someone read-only
    access to a repo; they either get read-write access or no access.

Gitolite does away with all this:

  * it uses ssh magic to remove the need to give actual unix userids to
    developers -- demystifying this is the subject of the next section
  * it uses a simple but powerful config file format to specify access rights
  * access control changes are affected by modifying this file, adding or
    removing user's public keys, and "compiling" the configuration
  * this also makes auditing trivial -- all the data is in one place.
    Versioning these configuration files is optional, but recommended, to get
    historical audit data
  * finally, the config file allows distinguishing between read-only and
    read-write access, not only at the repository level, but at the branch
    level within repositories.

### IMPORTANT -- overview of ssh

Here's a secret: ***gitolite uses far more ssh magic than git magic***!

This was true of gitosis as well.  Most people didn't realise this, and even
if they did they didn't know ssh well enough to help themselves.  If you don't
understand how ssh public key authentication works, or how the
`~/.ssh/authorized_keys` file can be used to restrict users, etc., you will
have endless amounts of trouble getting gitolite to work, because you'll be
attacking the wrong problem.

So please please please understand this before tearing your hair out and
blaming ***git/gitosis/gitolite*** for whatever is going wrong with your setup
:-)

#### ssh basics

Let's start with some basics, focusing *only* on the pieces relevant to
`gitolite`.  If this is not detailed enough, please use google and learn more
from somewhere, or maybe buy the OReilly ssh book.

  * You can login to an ssh server by typing a password, but ssh can also use
    ***public-private keys*** (also called "key pairs") for authentication.
    `gitolite` *requires* you to use this mechanism for your users -- they
    cannot log in using passwords.  Hopefully by the time you finish reading
    this document you will understand why :-)

    The way you set this up is you generate a key pair on your workstation,
    and give the server the public key.  (I need not add that the "private"
    key must be, well, kept *private*!)

  * **generating a key pair on your workstation** is done by running the
    command `ssh-keygen -t rsa`.  This produces two files in `~/.ssh`.  One is
    `id_rsa`; this is the **private** key -- ***never*** let it out of your
    machine.  The other is `id_rsa.pub`, which is the corresponding public
    key.  This public key is usually just one long line of text.

    * on Windows machines with msysgit installed, you should do this from
      within a "git bash" window.  The command will report the full path where
      the files have been written; make a note of this, and use those files in
      any of the description that follows

  * **adding your public key to the server**'s `~/.ssh/authorized_keys`
    file is how ssh uses pubkeys to authenticate users.  Let's say
    sita@work.station is trying to log in as git@serv.er.  What you have to do
    is take the `~/.ssh/id_rsa.pub` file for user sita on work.station and
    append its contents (remember it's only one line) to
    `~/.ssh/authorized_keys` for user git on serv.er.

    The `authorized_keys` file can have multiple public keys (from many
    different people) added to it so any of them can log in to git@serv.er.

    In the normal case (not gitolite, but your normal everyday shell access),
    there's a command that does this, `ssh-copy-id`, which also fixes up
    permissions etc., as needed, since sshd is a little picky about allowing
    pubkey access if permissions on the server are loose.  Or you can do it
    manually, as long as you know what you're doing and you're careful not to
    erase or overwrite the existing contents of `~/.ssh/authorized_keys` on
    the server!

    But in the gitolite case, it's different; we'll get to that in a minute.

    * **troubleshooting pubkey authentication failures**: if you are unable to
      get ssh access to the server after doing all this, you'll have to look
      in `/var/log/secure` or `/var/log/auth.log` or some such file on the
      server to see what specific error `sshd` is complaining about.

  * **restricting users to specific commands** is very important for gitolite.
    If you read `man sshd` and look for `authorized_keys file format`, you'll
    see a lot of options you can add to the public key line, which restrict
    the incoming user in various ways.  In particular, note the `command=`
    option, which means "regardless of what the incoming user is asking to do,
    forcibly run this command instead".

    Also note that when there are many public keys (i.e., lines) in the
    `authorized_keys` file, each line can have a *different* set of options
    and `command=` values.

    **This is the backbone of what makes gitolite work; please make sure you
    understand this**

#### how does gitolite use all this ssh magic?

These are two different questions you ought to be having by now: 

  * how does it distinguish between me and someone else, since we're all
    logging in as the same remote user "git"
  * how does it restrict what I can do within a repository

##### restricting shell access/distinguishing one user from another

The answer to the first question is the `command=` we talked about before.  If
you look in the `authorized_keys` file, you'll see entries like this (I chopped
off the ends of course; they're pretty long lines):

    command="[path]/gl-auth-command sitaram",[more options] ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA18S2t...
    command="[path]/gl-auth-command usertwo",[more options] ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEArXtCT...

First, it finds out which of the public keys in this file match the incoming
login.  That's crypto stuff, and I won't go into it.  Once the match has been
found, it will run the command given on that line; e.g., if I logged in, it
would run `[path]/gl-auth-command sitaram`.  So the first thing to note is
that such users do not get "shell access", which is good!

Before running the command, however, ssh sets up an environment variable
called `SSH_ORIGINAL_COMMAND` which contains the actual git command that your
workstation sent out.  This is the command that *would have run* if you did
not have the `command=` part in the authorised keys file.

When `gl-auth-command` gets control, it looks at the first argument
("sitaram", "usertwo", etc) to determine who you are.  It then looks at the
`SSH_ORIGINAL_COMMAND` variable to find out which repository you want to
access, and whether you're reading or writing.

Now is has user, repository, and access requested (read/write), gitolite looks
at its config file, and either allows or rejects the request.

But this cannot differentiate between different branches within a repo; that
has to be done separately.

##### restricting branch level actions

^^If you look inside the git source tree, there's a file among the "howto"s in
there called `update-hook-example.txt`, which was the inspiration for this
part of gitolite.^^

Git allows you to specify many "hooks", which get control as various events
happen -- see `git help hooks` for details.  One of those hooks is the
`update` hook, which, if it is present, is invoked just before a branch or a
tag is about to be updated.  The hook is passed the name of the branch or tag,
the old SHA1 value, and the new SHA1 value, as arguments.  Hooks that are
called *before* an action happens are allowed to prevent that action from
happening y returning an error code.

When gitolite is told to create a new repository (by the admin), it installs
a special update hook.  This hook takes all the information presented, looks
at the config file, and decides to allow or reject the update.

And that's basically it.

### installing git on the server

OK enough background, review, and hand waving.  On to the real stuff...

  * install git using your system's normal install mechanisms
  * (optional) check <http://www.kernel.org/pub/software/scm/git/> to see how
    old your distro-supplied git is.  If it's more than 6-12 months old,
    consider upgrading manually.  You can get the latest source code from that
    same URL.
  * some tips on compiling git:
    * installing git from sources must be done after installing *some* version
      of git, otherwise the version number does not get picked up properly --
      long story!
    * installing the dependencies required to compile git is out of scope of
      this document!  However, you can set `NO_CURL`, `NO_EXPAT`, and
      `NO_TCLTK`.  The first two will prevent http-pull/push from being built,
      but I never use those protocols anyway, so I don't care :-)  The third
      one will prevent the GUI tools from being built, which does not matter
      on a server
    * after installing this, remove the distro-installed git using `urpme` or
      `aptitude remove`.  Distros will usuall place git in some other place
      than a normal compile, and having two versions causes confusion.
      However, if this automatically removes anything else (like
      libdigest-sha1-perl and liberror-perl on ubuntu), install them back
      manually -- just in case!

### obtaining gitolite

  * clone gitolite: `git clone git://github.com/sitaramc/gitolite.git`
    * if you're behind a firewall and can't clone, send me an email

### #install installing and running it

If you're really impatient, here's the shortest possible "**how to install
gitolite right from your workstation**":

1.  get passwordless (pubkey) access to `git@server`
2.  clone the gitolite repo and cd to it
3.  run `src/00-easy-install.sh -q git server`

If you don't know what item #1 above means, or have any other problems, stop
being impatient, and read the real docs in the gitolite repo instead of this
one :) The INSTALL (or similarly named) file in the "doc/" directory is a good
start.

### troubleshooting

1.  a basic sanity check is to just try and `ssh git@your.gitolite.server`.
    If everything is setup properly, you should get an error that says
    something like `No SSH_ORIGINAL_COMMAND?`.

    This proves that ssh authenticated you by your private key, found that the
    corresponding public key line specifies `command=[path]/gl-auth-command
    youruserid`, and ran it, which promptly complained because it was
    expecting something that variable to be set.

### creating a separate "pushlog"

Gitolite maintains a log of who actually did the push, the name of the branch
or tag, and the old and new SHAs.  However, for simplicity, it puts all of
them in the same log file (all repos, all users!).

If you want something more granular, do the following:

Here's how to make that happen.

1.  create a `post-receive` file somewhere (maybe in `/tmp`) with the
    following contents, and make it executable (`chmod +x`)

        #!/bin/sh
        exec >> logs/pushlog
        date
        prefix="$(date +%s) $GL_USER"
        sed -e "s/^/$prefix /"
        EOF

    The date is written twice -- once in a user-friendly form for humans to
    look up, and once on each output line so things can be automated if
    needed.  Note that this *prefixes* the extra info to the data that git
    itself sends to the hook.

    An example output looks like this:

        Wed Jun  3 09:59:07 IST 2009
        1244003347 sitaram 4ce76ca6c4346dc7b14f5d3eca087241cf343f19 563f55309e8e22b7ee7b3d24450a1dbb860405a6 refs/heads/master

2.  copy this hook to all existing directories.  While you're about it, make
    sure the "logs" directory exists in all of them by setting a global
    option, as well as disable remote deletion of branches.

        su - git
        git config --global core.logAllRefUpdates true
        git config --global receive.denyDeletes true
        cd ~/repositories
        for i in *.git
        do
            cp /tmp/post-receive $i/hooks
        done

3.  **(this is the tricky bit)** make sure this becomes the default hook for
    any future repositories. [this is a TODO item for me... for now add it
    manually if you like.  Unlike gitosis, gitolite *does* maintain a log so
    you *do* have something to fallback upon.]

That should be it... make sure you test it!
