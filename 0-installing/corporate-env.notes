# git in a typical corporate environment

^^This document will describe, in detail, one way to **setup** git in a
corporate environment.  Sometimes, however, the detail takes the form of
actual commands with light commentary ;-)  Also, not every single detail has
been tested...  I'd like to be involved in the first run through this.

[[TOC]]^^

----

## constraints

To keep things more general, we'll do this without gitosis, the special
software that makes administering multiple git projects and users so easy.  We
will be assuming the following environment:

  * Server
    * OS: any standard Unix/Linux server
    * git software: pre-built or compiled (out of scope of this document)
  * Desktops:
    * Windows or Linux, doesn't matter
    * the [msysgit](http://code.google.com/p/msysgit/) version of git.  For
      installation etc., explore [this](../0-installing) page

Finally, to make things more interesting, we'll pretend we have a distributed
team working out of two locations, (say, Chennai and Zurich, to pick two
cities at random), and the network between these two is ok, but not the best.

## design

The best way to deal with this is to have *two* servers, one at each city.
Developers will only talk to their local server, and a designated person (or
persons) will synchronise the 2 servers as needed.

Here's the basic setup:

![Figure 1](../images/corp-1.png "basic setup")

### nomenclature

We'll call our servers C and Z, for their city names.  The project is called
"proj1", since we used up all our imagination coming up with city names ;-)
The git repo will be created to have this "group" (in terms of Unix
permissions), and all users with access to this project have to be made
members of this group.

One user on each server will be called "lead", in our examples.  There is no
special significance to this name; it's just for convenience, to highlight
activities that are performed by that person.  The other users are called
"user1", "user2", etc., in this document.

The "master" branch on each server will be called... **master**, and each
server will have a copy of the master branch of the other server, as
**c-master** and **z-master** respectively.

## one-time setup: server

### users and groups

On each server (C and Z), we have to do something like the following, for each
user.  Routine stuff like setting a password etc., are ignored here.

    # add the user
    useradd username
    # make him a member of the "proj1" group
    usermod -G proj1 username

<a name="make_bare">

### creating the bare repository

Any repository that people will **push** to has to be a **bare** repository.
Here's a detailed look at [why](../concepts-and-tips/bare.html).

To create the bare repo on the server, first pick a directory that everyone
will have access to.  We'll use `/var/gitrepos` in our examples.

    # as root
    mkdir /var/gitrepos
    chown lead /var/gitrepos

    # as user "lead"
    cd /var/gitrepos

    # make the repo for proj1, including adjusting permissions
    mkdir proj1.git     # it's a convention to suffix ".git" if the
                        # repo is a "bare" repo
    cd proj1.git
    git init --bare --shared
    chgrp -R proj1 .

    # git does not set this flag by default; I wish it would!
    git config core.logallrefupdates true

Note: that last step above (setting the config variable) is **very
important**.

At this point we have a "bare" repository on the server.  It is also empty --
we have not made any commits in it yet.

## one-time setup: developers' desktop

### global setup steps

The following steps need to be performed by any developer, just once.

Open "file explorer", right click on any directory, and choose "Git Bash
here".  We just want a command line; in this step we don't care what the
directory actually contains.

You will get a terminal screen.  Now type in the following commands:

    # identify yourself to git for future use
    git config --global user.email "your.name@company.com"
    git config --global user.name  "Your Name"

    # this setting is new in modern gits and is very useful
    git config push.default nothing

    # these 3 settings let you edit files from within "git gui"
    # "write.exe" is wordpad; change it whatever you want
    git config guitool.Edit.cmd 'write.exe $FILENAME'
    git config guitool.Edit.noconsole yes
    git config guitool.Edit.needsfile yes

(Side note: if you're going to use passwordless auth on ssh, you need this.
For more details, go [here](../0-installing/2-access-gitosis.html)).

    ssh-keygen -t rsa

Now type `exit` (or hit Ctrl-D) to exit.

### create the repo and push to server ("lead" developer only)

Start with a fresh, clean, ironed, copy of the latest source code in some
directory.  Open "file explorer" to the parent of this directory, right click
on this directory, and choose "Git Bash here".

Now type in the following:

    # initialise the repository
    git init

    # create a ".gitignore" file and populate it with stuff like "*.exe",
    # "*.dll", etc., one on each line, no quotation marks.
    vim .gitignore
    # or use the gui to create a plain text file called ".gitignore".  That's
    # the exact, complete, name :-)

    # stage the .gitignore file
    git add .gitignore

    # commit it
    git commit  # this opens an editor so you can type the commit message
                # --- OR ---
    git commit -m "gitignore file created"

    # now stage and commit the rest of the files
    git add .
    git commit -m "first commit of the source tree"

At this point you have a nice repo with 2 commits on the "master" branch.  You
now need to push this to the server.

    # add a "remote" called "origin" that points to the server
    git remote add origin lead@server.ip:/var/gitrepos/proj1.git

    # push the branch
    git push origin master

And you're done.  The server now has the repository.  Other users can clone
this, as in the next section.

### clone the repo from the server (other developers)

Create an empty directory to work in.  Right click on this empty directory,
and click "Git bash here".  You'll get a terminal.  Now type in:

    git clone user1@server.ip:/var/gitrepos/proj1.git .

Note the `"."` at the end.  Without it, you will get a subdirectory called
`proj1` which contains the "clone".  With the `"."`, the clone is in this
directory itself.

That's it; you can start working on git in this directory!

## connectivity between the servers

### create a bundle to send to Zurich

If the repository is very large, and if network connectivity is not that good,
it may be useful to send the initial clone as a normal file (later updates
will be much smaller, and can use normal `git push` etc.).  Here's how to
create and send that file.

On the Chennai server:

    git bundle create /tmp/bundle.file master

Now take the bundle file and ftp/email/carrier-pigeon it to Zurich.  On the
Zurich server, first create a bare repository the same way described
[above](#make_bare).  Then, do this:

    cd /var/gitrepos/proj1.git
    git fetch /tmp/bundle.file master:master

That's it.  Your clone is created.

**VERY IMPORTANT NOTE**:  This does not mean that Chennai is the "master"
server and Zurich is the "clone".  In git, all clones are equal.  Master/clone
distinctions are **purely administrative**.  See next section for more on
this.

### setting up remotes between the 2 servers

Once network connectivity has been established, you can set up a remote on
each server for the other one.  We'll use the Chennai server as an example;
just replace the appropriate values to do this on Zurich.

Naturally, for this to work, someone (perhaps the "lead" developer) on one
side needs to have a login on the other side's server!

    cd /var/gitrepos/proj1.git
    git remote add zurich lead@zurich.server.com:/var/gitrepos/proj1.git

## ongoing sync between the two servers

### fetching updates from the other side

**This can be automated; but we'll do that later, once things are stable...**

You can get updates from the other server very easily.  Again, using the
Chennai server:

    cd /var/gitrepos/proj1.git
    git fetch zurich master:zurich-master

That's it.  This gets you the latest version of "master" from the Zurich
server, calling it "zurich-master" on your side (that's what that syntax is
doing).  At this point, if you run `git branch -a`, you'd see something like
this:

    \* master
      zurich-master

Running `git branch -a -v` would show you a little more detail:

    \* master        2216d56 latest commit on chennai master
      zurich-master 283ff39 latest commit on zurich master

You'd do a similar thing on Zurich to get Chennai's "master" and other
branches.

However, this is only the beginning.  You need to merge the code changes!

### merging Zurich code into Chennai master

Merging cannot be done on a "bare" repository.  Without a working directory,
there is no way to resolve conflicts, in case they arise, so this is not
possible.

This means the merge has to be done on one of the developer's desktops.

Also, we'll assume, for our discussion, that Zurich is the "customer facing"
site and so their code is the "main" one.  This means there is now an
*asymmetry* between the 2 servers (until now, everything we do on one, we'd do
exactly the same on the other server).

In Chennai, we'd do this:

1.  fetch updates from Zurich as above

2.  on "lead" developer's PC, we'd do the following:

        git fetch origin

    This will get you a branch called "origin/zurich-master" (check this with
    `git branch -a`).  The "lead" developer has to merge changes from
    "origin/zurich-master" into his own "master".

        # checkout your master branch
        git checkout master
        # make sure your work tree is clean
        git status
        # should report:
        #       # On branch master
        #       nothing to commit (working directory clean)

        # merge...
        git merge origin/zurich-master

3.  Now if there are conflicts, you have to resolve them manually (using
    either the GUI and/or some editor), then add files, and commit.

4.  And finally, push the new master to the server

        git push origin master

At this point, the Chennai server has the latest updates from Zurich included
in its "master" branch.  Developers get those changes when they do a `git
pull` or `git fetch` etc.

### merging Chennai code into Zurich master

Remember that Zurich has a slightly different role.  The "master" branch in
Zurich represents a somewhat more "sacred" version than the Chennai master.
For example, perhaps production releases are being made from this "master".

So, while Chennai just merged the zurich-master into their master, Zurich will
not be doing precisely that.  Here's how Zurich would do this:

1.  fetch updates from Chennai as above

2.  on "lead" developer's PC, we'd do the following:

        git fetch origin

    This will get you a branch called "origin/chennai-master" (check this with
    `git branch -a`).  The "lead" developer has to **test merge** changes from
    "origin/chennai-master" into his own "master".

    What is needed is a way to attempt a merge, but not on the "master"
    branch.  This way, if the merge or the merged code fails for any reason
    (too many conflicts, fails to build, fails regression tests, etc), then we
    simply discard the temporary branch on which we merged.  If things worked
    out, we merge the "test-merge" branch into the "master" branch.

    Git makes such **test merges** trivially easy.  Following the same process
    as before, note the extra step in between:

        # checkout your master branch
        git checkout master
        # make sure your work tree is clean
        git status
        # should report:
        #       # On branch master
        #       nothing to commit (working directory clean)

        # create a test-merge branch off of "master".  The "-f" deletes and
        # re-creates the branch if it already existed, so make sure you don't
        # use some other, more permanent, branch name in place of "test-merge"
        # :-)
        git branch -f test-merge
        # now checkout this branch, so all activity is now here
        git checkout test-merge

        # merge...
        git merge origin/chennai-master

3.  As before, if there are conflicts, you have to resolve them manually
    (using either the GUI and/or some editor), then add files, and commit.

4.  Now you need to build, regression test, etc.  If something went wrong, you
    do this:

        git checkout master
        git branch -D test-merge    # not strictly needed...

    Once Chennai sends a new and improved version, you try a merge with that
    now.

5.  On the other hand, if everything worked fine, you'd do this:

        git checkout master
        git merge test-merge
        # and push to the server...
        git push origin master

    (You could also do `git merge chennai-master` if you're sure there were no
    changes made during the test-merge or during testing, but it is generally
    unsafe to do so, due to human error.  What you tested is what you
    merge...)
