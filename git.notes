= git -- Linus Torvalds's second masterpiece!

[[TOC 5]]

----

=== basic concepts and simple tips

  * a branch is "an active line of development"
  * //master//: default branch in a project
  * //head//: tip of a branch
  * a repo can track many branches, but the working tree is associated with
    only one branch
  * //HEAD//: tip of the branch associated with the working tree; this is
    where commits go
    ** except when it's "detached"
  * //index//: a staging area for the next commit; when you commit, the
    current index is turned into a real commit object
  * {{{gitk --all}}} is your friend, or you can give it a path also
  * set your name in the config as shown below, but it is useful not to set
    your email, so that you can be reminded what machine was used to make a
    particular change
  * man pages frustrating?  Look at the examples first!

=== simple gotchas

  * **gotcha** {{{git log rev}}} and {{{git diff rev}}} go in different
    directions.  Log shows backward from the rev given, while diff goes
    forward from rev to the working directory.
  * many commands inherit options from lower level programs and their man
    pages will appear incomplete.  Read carefully to see what other commands'
    options are applicable to this one.  For example, {{{git-log}}} inherits
    from {{{git-rev-list}}} and {{{git-diff-tree}}}.
  * using {{{cp -a}}} copy instead of {{{git clone}}} will screw the
    timestamps.  A subsequent {{{git add .}}} will make it look like every
    file has changed, in terms of just the time stamp.  //Fix this by using
    {{{git status}}}, which updates the index for such cases as a side
    effect.//
  * confused by {{{HEAD^}}}, {{{HEAD~1}}}, etc.?  {{{man git-rev-parse}}} has
    a good diagram.  And remember the reflog is quite different and has a
    different syntax ({{{HEAD@{2}}}}).
  * cloning a repo: the following two commands are different; see
    http://kerneltrap.org/mailarchive/git/2007/10/1/326757 (summary: the
    second one uses the git protocol, and makes no assumptions about the
    original and the clone being on the same file system or even machine)
        git clone foo bar           # versus
        git clone file:///foo bar

=== really cool stuff

  * http://www.kernel.org/pub/software/scm/git/docs/howto/rebase-from-internal-branch.txt
    -- excellent article on rebase. This article is also available in the git
    installs, at least on MDV.  We already knew git was smart about not
    re-applying patches already applied, based on the SHA1 being in the chain.
    But the **really cool** thing about rebase is that it can ignore patches
    even when they had a different SHA1 (in the same way that git cherry does,
    by examining the changeset) which helps when your changes may have made it
    into the master via email.  AWESOME!
  * **cherry picking** -- really cool.  Another good reason to make small
    commits :-)
  * cherry picking while doing a rebase; {{{man git-rebase}}} for details.  In
    particular, you can rebase off of your own ancestor, to refactor a large
    set of recent changes, like this:
        git rebase -i HEAD~10
    ** YOU DON'T KNOW HOW COOL THIS IS UNTIL YOU TRY IT!
  * Advantages of doing a rebase: doing a {{{git bisect}}} on a merged chain
    sometimes makes it difficult to find the specific commit that caused an
    error.  See
    http://www.kernel.org/pub/software/scm/git/docs/user-manual.html#bisect-merges
  * {{{git stash}}}
    ** this can be simulated, and some say it's better to simulate git stash
       than actually use it!  The following makes use of the fact that the
       repo HEAD is usually one step behind the index, which is one step
       behind the working tree.
        # initial values: R (repo), I (index), C (changed), and U (untracked)
        # notation: repo contents/index contents/work tree contents
        # R/RI/RICU; start
        git commit -m wip-index-state
        # now RI/RI/RICU; pushed index onto repo
        git add -A && git commit -m wip-worktree-state
        # now RICU/RICU/RICU; pushed C/U files onto repo
            #   ... switch branch, work work work, commit ...
            #   now you want to get back to the saved state
        # go back to whatever branch it was
        git checkout whatever
        # now RICU/RICU/RICU
        git reset --mixed HEAD^ # repo=index=R+I
        # now RI/RI/RICU; moved HEAD and index back one step
        git reset --soft HEAD^
        # now R/RI/RICU; moved HEAD back one more step

  * {{{git bundle}}}: really awesome, but be careful, not all refspecs will
    work on the receiving side.  Assuming we're talking about a normal
    "origin" pull for an existing clone, this is what you do
        # sending side
        git bundle create ~/junk HEAD^^^..
            # (or something like "254c8de4..", assuming the receiving side has
            # that hash)
        # receiving side
        git fetch ~/junk [refs/heads/]master:[refs/]remotes/origin/master
            # the part in brackets is optional; the rest is not
        git merge origin
        # (not sure how to do a clone with this method)

=== the bleeding edge

  * making an independent branch in an existing repo (from
    http://madduck.net/blog/2007.07.11:creating-a-git-branch-without-ancestry/)
        git status  # ensure all clear
        git symbolic-ref HEAD refs/heads/indbr
        rm .git/index
        ...create new tree as you like...
        git add .
        git commit -m "first commit of independent branch"

=== questions

  * can you make the working copy and the HEAD agree, while the index does
    not? -- seems you can
  * how do you find out how many remotes you have and what they are called?
        vim .git/config                         # or...
        git remote | map git remote [-n] show   # even better!
            # use -n to prevent lookup if needed

  * what the heck is a //reflog// and why is it so important?
    ** from a comment in
       http://blogs.gnome.org/newren/2007/11/24/local-caching-a-major-distinguishing-difference-between-vcses/,
       it seems to be: a very special "branch" since it records each position
       of HEAD in the last 30 days (by default). So removed branches wonâ€™t be
       purged by purge [he might have meant prune] until after waiting for 30
       days, when the last reference to them will finally be released.
    ** and I managed to understand it, after hard-resetting a commit and then
       creating a new one to replace it, then looking at {{{git-show-branch
       -g}}} (shows you a gap in the bottom pattern, plus you see that
       branches {{{master@{1}}}} and {{{master@{3}}}} have the same set of
       commits reading vertically), and then git-reflog, where you will see
       that {{{HEAD@{1}}}} and {{{HEAD@{3}}}} are the same
    ** reflog history is not shared -- it is exclusive to your repository.
       This is the only thing you lose if you clone a project as a means of
       performing a backup.

  * verify-pack gives you a list of all the objects in the pack.  How do you
    find stuff that is not yet packed?

=== some URLs

  * http://cworth.org/hgbook-git/tour/ -- I cannot emphasise how useful this
    URL has been in getting started!
  * http://www.kernel.org/pub/software/scm/git/docs/everyday.html is also a
    great quick ref
  * http://www.kernel.org/pub/software/scm/git/docs/glossary.html
  * http://eagain.net/articles/git-for-computer-scientists
  * http://git.or.cz/gitwiki/GitCheatSheet
  * who says git is harder than SVN?  Try http://git.or.cz/course/svn.html
  * very nice, pictorial, explanation at
    http://www.kernel.org/~junio/200607-ols.pdf

=== some advocacy URLs :-)
  * http://tech.slashdot.org/comments.pl?sid=499412&cid=22866970
  * http://cubist.cs.washington.edu/Security/category/security-reviews/

  * http://www.advogato.org/person/apenwarr/diary/371.html

  * http://www.developsense.com/testing/VSSDefects.html

  * http://creativekarma.com/ee.php/weblog/comments/why_clearcase_sucks/
  * http://www.digitaltorque.ca/2006/12/18/clearcase-making-easy-things-hard/
  * http://selenic.com/pipermail/mercurial/2007-April/012864.html
  * http://www.trolocsis.com/wp/2007/04/18/the-joys-of-clearcase/
  * http://www.germane-software.com:8080/ser/aikido/clearcase-sucks
  * http://evilparty.org/~orc/2004/08/03/001/index.html

  * http://weblog.masukomi.org/2008/2/4/some-thoughts-about-git (cf Hg)
     
  * http://kb.perforce.com/UserTasks/WorkingDisconnected
  * http://luqui.org/blog/archives/2007/02/19/perforce-sucks/
  * http://www.redhillconsulting.com.au/blogs/simon/archives/000358.html

  * http://codicesoftware.blogspot.com/2007/05/linus-torvalds-on-git-and-scm.html
  * http://www.betaversion.org/~stefano/linotype/news/106/
  * on tracking content instead of files: http://marc.info/?l=git&m=116473016012824

  * descriptive article on the advantages of a DVCS and speculative branching
    and low overhead repos and so on:
    http://griddlenoise.blogspot.com/2007/12/distributed-vcss-are-great-enablers-or.html

  * on why git is so revolutionary.  This is actually the most "concept-ish"
    of all the praising articles on git, and yet the most tangible because he
    keeps on pumping us with examples of stuff he and others had done which
    could ALL be replaced by git:
    http://www.advogato.org/person/apenwarr/diary/371.html.  Has stuff like "I
    wanted to build distributed filesystem, but git beat me to it; I wanted a
    file backup system, but git beat me to it", etc., essentially saying that
    git is a platform for building whatever you want, not just a VCS.  Or how
    about a "hash indexed backup system" to store backups from different
    systems efficiently?

=== funny stuff
  * http://changelog.complete.org/posts/698-If-Version-Control-Systems-were-Airlines.html
    -- esp the last 2 "airlines".  No wonder I like git so much :-)
