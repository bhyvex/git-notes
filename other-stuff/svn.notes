# for people who think SVN is good enough ;-)

The official comparison is [here](http://git.or.cz/gitwiki/GitSvnComparsion).
There is also a [Git - SVN crash course](http://git-scm.com/course/svn.html).

*Lots of SVN info is scattered in a few other files in this directory;
eventually it should all be pulled into this file.*

^^as Churchill said, so much to do, and so little time in which to do it... (*sigh*)^^

[[TOC]]

----

#### 'svn update' on very active projects

When you, as a developer, have made a fair number of changes on your
workstation, and wish to commit these to the SVN repo, you do an 'svn update'.
This brings in the latest changes from the server.

Unfortunately, if the other developers have also been very active, there could
be a lot of new/changed code.  All of those changes, in one fell swoop, are
now merged into your working copy, so conflicts are very likely.

Worse, the 'svn update' has managed to lose the separation between your local
changes and the updates that came from the server.  You now have exactly one
chance to resolve those conflicts and commit the result.  And you'd better do
it fast -- before the upstream tree changes *again*!

[This is when an SVN newbie will realise he should have backed up his current
source tree using tar or zip ;-)]

With git, you would not do the `git pull` while you still have uncommitted
changes in your local repository.  This is a *distributed* VCS, so you have a
local repository to take care of all that.

So just commit all *your* changes locally, and *then* do a `git pull`!

Of course this will have the same conflicts as in SVN and you still have to do
a manual conflict resolution, *but*:

1.  your local changes are *cleanly* saved, so if you botch up the manual
    conflict resolution, you can go back to your last local commit and try
    again.  As many times as you need to, really.
2.  if you do a `git pull --rebase`, (which is closer to what SVN does
    actually), then git will apply your local changes *one commit at a time*
    instead of the whole thing in one shot, making the conflict resolution
    also go in small, easily digestible chunks.
3.  in rare cases, the 'upstream' has changed so much that a lot of your local
    changes become invalid and you have to redo them.  With SVN -- you have to
    throw the whole lot away and start again.  With git, you would have made a
    series of small, granular, commits on your local tree, and this lets you
    salvage the pieces that are still acceptable and redo only those that are
    not.  Then you do your `git pull` or `git pull --rebase` again.

^^Basic idea from a post by Junio at
<http://article.gmane.org/gmane.comp.version-control.git/110671>^^

#### local caching and repository size

##### What extra information is is cached locally?

When you do an 'svn checkout', you get a working copy of the revision you
checked out, plus svn saves away an extra copy of the same stuff.  This allows
you to do things like see what you changed with respect to the checked out
version.

But if you need a diff between your copy and some other version, you need
network access.  If you need a diff between two checked-in revisions, again
you need network access.

When you do a `git clone`, however, git stores the complete history of all the
branches that the parent repository has!  So the only time you now need
network access is when you want to update the server, nothing else.

This might make you think git's repositories are *huge*!  Far from it; here's
[an example](http://keithp.com/blogs/Repository_Formats_Matter/) that uses the
Mozilla repository, with full history from 1998 or so:

  * CVS repo: 2.7 GB
  * imported to SVN: 8.2 GB
  * imported to GIT: 450 MB!
  * (a full checkout of just the source: 350 MB)

That's a ratio of almost 20:1 in size over SVN.

#### some links

  * <http://markmcb.com/2008/10/18/3-reasons-to-switch-to-git-from-subversion/>:
    the first example, 'Endless, Easy, Non-File-System-Based, Local Branches',
    is particularly powerful and convincing
